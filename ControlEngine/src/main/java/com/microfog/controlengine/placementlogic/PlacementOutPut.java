package com.microfog.controlengine.placementlogic;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.microfog.controlengine.model.domainObjects.Placement;
import com.microfog.controlengine.model.domainObjects.PlacementRequest;

import java.util.*;

public class PlacementOutPut {

    /**
     * After execution of each placement algorithm, below fields should be updated based on the generated placement
     */

    //details of the microservice mapping generated by control-engine
    Map<String, Map<String,Placement>> placement = new HashMap<>(); //application id -> (microservice -> device mappings)

    // with updated "Placed Microservice" lists. Used in distributed placement approaches to forward
    List<PlacementRequest> incompletePRs = new ArrayList<>();

    List<PlacementRequest> completedPRs = new ArrayList<>();

    // to check deployment of gateway resources for ingress access : application => access clusters
    Map<String,List<String>> accessCluster = new HashMap<>();

    @JsonCreator
    @JsonPropertyOrder({"applicationId", "placedMicroservices","entryClusters"})
    public PlacementOutPut(Map<String, Map<String,Placement>> placement, List<PlacementRequest> incompletePRs, List<PlacementRequest> completedPRs){
        this.placement = placement;
        this.incompletePRs = incompletePRs;
        this.completedPRs = completedPRs;
    }

    public PlacementOutPut() {
        System.out.println("Placement Output initialised");
    }

    public void addToPlacement(String app, String microservice, String clusterName, String nodeName){
        if(!placement.containsKey(app))
            placement.put(app,new HashMap<>());
        if(!placement.get(app).containsKey(microservice)) {
            Placement p = new Placement(microservice);
            p.addDeviceMapping(clusterName,nodeName, 1);
            placement.get(app).put(microservice, p);
        }
        else{
            placement.get(app).get(microservice).addDeviceMapping(clusterName,nodeName);
        }
    }

    public void addToPlacement(String app, String microservice, String clustername, String nodeName,Integer scalingFactor){
        if(!placement.containsKey(app))
            placement.put(app,new HashMap<>());
        if(!placement.get(app).containsKey(microservice)) {
            Placement p = new Placement(microservice);
            p.addDeviceMapping(clustername,nodeName, scalingFactor);
            placement.get(app).put(microservice, p);
        }
        else{
            placement.get(app).get(microservice).addDeviceMapping(clustername,nodeName,scalingFactor);
        }
    }

    public List<PlacementRequest> getIncompletePRs() {
        return incompletePRs;
    }

    public Map<String, Map<String, Placement>> getPlacement() {
        return placement;
    }

    public List<String> GetAccessClusters(String app){
        return  accessCluster.get(app);
    }

    public void setIncompletePRs(List<PlacementRequest> incompletePRs) {
        this.incompletePRs = incompletePRs;
    }

    public void addAccessClusters(String app, List<String> clusterNames){
        accessCluster.put(app,clusterNames);
    }

    public void addIncompletedPrs(PlacementRequest pr) {
        incompletePRs.add(pr);
    }

    public void addCompletedPrs(PlacementRequest pr) {
        completedPRs.add(pr);
    }

    public List<PlacementRequest> getCompletedPRs() {
        return completedPRs;
    }

}
